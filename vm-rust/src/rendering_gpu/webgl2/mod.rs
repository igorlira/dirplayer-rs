//! WebGL2 GPU-accelerated renderer
//!
//! This module provides hardware-accelerated rendering using WebGL2.
//! It renders sprites as textured quads with shaders implementing
//! Director's ink modes for pixel-perfect compatibility.
//!
//! This is work in progress - the renderer is not yet fully functional.

mod context;
mod geometry;
mod shaders;
mod texture_cache;

use itertools::Itertools;
use wasm_bindgen::{JsCast, JsValue};
use web_sys::{HtmlCanvasElement, WebGl2RenderingContext};

use std::collections::HashMap;

use crate::player::{
    bitmap::bitmap::{get_system_default_palette, resolve_color_ref, Bitmap, PaletteRef},
    bitmap::drawing::CopyPixelsParams,
    cast_lib::CastMemberRef,
    cast_member::CastMemberType,
    font::{measure_text, BitmapFont},
    geometry::IntRect,
    handlers::datum_handlers::cast_member::font::{FontMemberHandlers, StyledSpan, HtmlStyle, TextAlignment},
    score::{get_concrete_sprite_rect, ScoreRef},
    sprite::ColorRef,
    DirPlayer,
};
use crate::rendering::{render_score_to_bitmap_with_offset, FilmLoopParentProps};

pub use context::WebGL2Context;
pub use geometry::QuadGeometry;
pub use shaders::{InkMode, ShaderManager};
pub use texture_cache::{TextureCache, TextureCacheKey, RenderedTextCache, RenderedTextCacheKey};

/// WebGL2 hardware-accelerated renderer
///
/// This renderer uses WebGL2 to offload compositing to the GPU,
/// freeing up CPU cycles for script execution.
#[allow(dead_code)]
pub struct WebGL2Renderer {
    /// WebGL2 context wrapper
    context: WebGL2Context,
    /// Main canvas element
    canvas: HtmlCanvasElement,
    /// Preview canvas element (uses Canvas2D for simplicity)
    preview_canvas: HtmlCanvasElement,
    /// Preview 2D context for member preview rendering
    preview_ctx2d: web_sys::CanvasRenderingContext2d,
    /// Canvas size
    size: (u32, u32),
    /// Preview size
    preview_size: (u32, u32),
    /// Shader manager for ink mode shaders
    shader_manager: ShaderManager,
    /// Texture cache for bitmap textures
    texture_cache: TextureCache,
    /// Quad geometry for sprite rendering
    quad: QuadGeometry,
    /// Orthographic projection matrix (column-major for WebGL)
    projection_matrix: [f32; 16],
    /// Frame counter for debug logging
    frame_count: u64,
    /// Debug: currently selected channel number for inspector
    pub debug_selected_channel_num: Option<i16>,
    /// Solid color texture cache (keyed by RGB tuple)
    solid_color_textures: HashMap<(u8, u8, u8), web_sys::WebGlTexture>,
    /// Current preview member reference
    preview_member_ref: Option<CastMemberRef>,
    /// Preview container element
    preview_container_element: Option<web_sys::HtmlElement>,
    /// Rendered text texture cache
    rendered_text_cache: RenderedTextCache,
    /// Last known palette version - used to clear texture cache when palettes change
    last_palette_version: u32,
}

impl WebGL2Renderer {
    /// Create a new WebGL2 renderer
    pub fn new(
        canvas: HtmlCanvasElement,
        preview_canvas: HtmlCanvasElement,
    ) -> Result<Self, JsValue> {
        let gl = canvas
            .get_context("webgl2")?
            .ok_or_else(|| JsValue::from_str("WebGL2 not supported"))?
            .dyn_into::<WebGl2RenderingContext>()?;

        let context = WebGL2Context::new(gl)?;
        let shader_manager = ShaderManager::new(&context)?;
        let texture_cache = TextureCache::new();
        let quad = QuadGeometry::new(&context)?;

        let size = (canvas.width(), canvas.height());
        let preview_size = (preview_canvas.width(), preview_canvas.height());

        // Create Canvas2D context for preview rendering
        let preview_ctx2d = preview_canvas
            .get_context("2d")?
            .ok_or_else(|| JsValue::from_str("Failed to get 2D context for preview"))?
            .dyn_into::<web_sys::CanvasRenderingContext2d>()?;

        // Create initial orthographic projection matrix
        let projection_matrix = Self::create_ortho_matrix(size.0 as f32, size.1 as f32);

        Ok(Self {
            context,
            canvas,
            preview_canvas,
            preview_ctx2d,
            size,
            preview_size,
            shader_manager,
            texture_cache,
            quad,
            projection_matrix,
            frame_count: 0,
            debug_selected_channel_num: None,
            solid_color_textures: HashMap::new(),
            preview_member_ref: None,
            preview_container_element: None,
            rendered_text_cache: RenderedTextCache::new(),
            last_palette_version: 0,
        })
    }

    /// Create an orthographic projection matrix (column-major for WebGL)
    /// Maps (0,0)-(width,height) to (-1,-1)-(1,1) with Y flipped for screen coords
    fn create_ortho_matrix(width: f32, height: f32) -> [f32; 16] {
        // Ortho projection: x: 0..width -> -1..1, y: 0..height -> 1..-1 (flip Y)
        let sx = 2.0 / width;
        let sy = -2.0 / height;  // Negative to flip Y
        let tx = -1.0;
        let ty = 1.0;

        // Column-major 4x4 matrix
        [
            sx,  0.0, 0.0, 0.0,  // column 0
            0.0, sy,  0.0, 0.0,  // column 1
            0.0, 0.0, 1.0, 0.0,  // column 2
            tx,  ty,  0.0, 1.0,  // column 3
        ]
    }

    /// Check if WebGL2 is available
    pub fn is_supported() -> bool {
        super::is_webgl2_supported()
    }

    /// Draw the current frame
    pub fn draw_frame(&mut self, player: &mut DirPlayer) {
        self.frame_count += 1;

        // Check if palettes changed and clear texture cache if so
        // This handles external cast loading where palette members may load after initial render
        let current_palette_version = player.movie.cast_manager.palette_version();
        if current_palette_version != self.last_palette_version {
            self.texture_cache.clear();
            self.last_palette_version = current_palette_version;
        }

        // Clear with stage background color
        let bg_color = self.get_stage_bg_color(player);
        {
            let gl = self.context.gl();
            gl.clear_color(bg_color.0, bg_color.1, bg_color.2, 1.0);
            gl.clear(WebGl2RenderingContext::COLOR_BUFFER_BIT);
        }

        // Advance texture cache frame counters
        self.texture_cache.next_frame();
        self.rendered_text_cache.next_frame();

        // Get sorted channel numbers for current frame
        let sorted_channels: Vec<(i16, i32)> = player
            .movie
            .score
            .get_sorted_channels(player.movie.current_frame)
            .iter()
            .map(|x| (x.number as i16, x.sprite.loc_z))
            .collect_vec();

        // Bind quad geometry once
        self.quad.bind(self.context.gl());

        // Render each sprite
        for (channel_num, _) in &sorted_channels {
            self.render_sprite(player, *channel_num);
        }

        // Draw debug text overlay (datum count, script count)
        self.draw_debug_text_overlay(player);

        // Unbind
        self.quad.unbind(self.context.gl());

        // Draw debug highlight for selected channel
        if let Some(selected_channel) = self.debug_selected_channel_num {
            self.draw_debug_highlight(player, selected_channel);
            // Reset shader manager state since draw_debug_highlight uses its own shader
            // and calls gl.use_program(None), which desynchronizes the manager's cached state
            self.shader_manager.clear_active();
        }
    }

    /// Get stage background color as normalized floats
    fn get_stage_bg_color(&self, player: &DirPlayer) -> (f32, f32, f32) {
        let palettes = player.movie.cast_manager.palettes();
        let (r, g, b) = resolve_color_ref(
            &palettes,
            &player.movie.stage_color_ref,
            &PaletteRef::BuiltIn(get_system_default_palette()),
            8, // bit depth
        );
        (r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0)
    }

    /// Draw debug text overlay showing datum and script counts
    fn draw_debug_text_overlay(&mut self, player: &mut DirPlayer) {
        // Get system font
        let font = match player.font_manager.get_system_font() {
            Some(f) => f,
            None => return, // No font available
        };

        // Get font bitmap
        let font_bitmap = match player.bitmap_manager.get_bitmap(font.bitmap_ref) {
            Some(b) => b,
            None => return, // No font bitmap
        };

        // Create debug text
        let txt = format!(
            "Datum count: {}\nScript count: {}",
            player.allocator.datum_count(),
            player.allocator.script_instance_count()
        );

        // Measure text to determine texture size
        let (text_width, text_height) = measure_text(&txt, &font, None, 0, 0);
        let width = (text_width as u32).max(1);
        let height = (text_height as u32).max(1);

        // Create a 32-bit RGBA bitmap for rendering text
        let mut text_bitmap = Bitmap::new(
            width as u16,
            height as u16,
            32,
            32,
            0,
            PaletteRef::BuiltIn(get_system_default_palette()),
        );

        // Bitmap::new initializes 32-bit data to 255 (white/opaque)
        // We'll make white pixels transparent after rendering text

        let palettes = player.movie.cast_manager.palettes();

        // Set up copy parameters for text rendering with background transparent ink
        let params = CopyPixelsParams {
            blend: 100,
            ink: 36, // Background transparent
            color: ColorRef::Rgb(0, 0, 0), // Black text
            bg_color: ColorRef::Rgb(255, 255, 255), // White background (transparent)
            mask_image: None,
            is_text_rendering: true,
            rotation: 0.0,
            sprite: None,
            original_dst_rect: None,
        };

        // Render text to the bitmap
        text_bitmap.draw_text(
            &txt,
            &font,
            font_bitmap,
            0,
            0,
            params,
            &palettes,
            0,
            0,
        );

        // After drawing text, convert white pixels to transparent
        for i in 0..text_bitmap.data.len() / 4 {
            let r = text_bitmap.data[i * 4];
            let g = text_bitmap.data[i * 4 + 1];
            let b = text_bitmap.data[i * 4 + 2];
            if r >= 250 && g >= 250 && b >= 250 {
                text_bitmap.data[i * 4 + 3] = 0;
            }
        }

        // Upload the bitmap as a texture
        let texture = match self.context.create_texture() {
            Ok(t) => t,
            Err(_) => return,
        };
        if self.context.upload_texture_rgba(&texture, width, height, &text_bitmap.data).is_err() {
            return;
        }

        // Draw the debug text texture at top-left corner
        let ink_mode = InkMode::Copy;
        let effective_ink = self.shader_manager.use_program(&self.context, ink_mode);

        let program = match self.shader_manager.get_program(effective_ink) {
            Some(p) => p,
            None => return,
        };

        self.context.set_blend_alpha();

        let gl = self.context.gl();

        // Set projection matrix
        if let Some(ref loc) = program.u_projection {
            gl.uniform_matrix4fv_with_f32_array(Some(loc), false, &self.projection_matrix);
        }

        // Bind texture
        gl.active_texture(WebGl2RenderingContext::TEXTURE0);
        gl.bind_texture(WebGl2RenderingContext::TEXTURE_2D, Some(&texture));
        if let Some(ref loc) = program.u_texture {
            gl.uniform1i(Some(loc), 0);
        }

        // Set sprite rect uniform (position at 0,0 with text dimensions)
        if let Some(ref loc) = program.u_sprite_rect {
            gl.uniform4f(Some(loc), 0.0, 0.0, width as f32, height as f32);
        }

        // Set texture rect (full texture)
        if let Some(ref loc) = program.u_tex_rect {
            gl.uniform4f(Some(loc), 0.0, 0.0, 1.0, 1.0);
        }

        // No flip
        if let Some(ref loc) = program.u_flip {
            gl.uniform2f(Some(loc), 0.0, 0.0);
        }

        // No rotation
        if let Some(ref loc) = program.u_rotation {
            gl.uniform1f(Some(loc), 0.0);
        }
        if let Some(ref loc) = program.u_rotation_center {
            gl.uniform2f(Some(loc), 0.0, 0.0);
        }

        // Full blend
        if let Some(ref loc) = program.u_blend {
            gl.uniform1f(Some(loc), 1.0);
        }

        // Draw the quad
        self.quad.draw(gl);

        // Cleanup
        gl.bind_texture(WebGl2RenderingContext::TEXTURE_2D, None);
        gl.delete_texture(Some(&texture));
    }

    /// Draw debug highlight rectangle around selected sprite
    fn draw_debug_highlight(&self, player: &DirPlayer, channel_num: i16) {
        let sprite = match player.movie.score.get_sprite(channel_num) {
            Some(s) => s,
            None => return,
        };

        let rect = get_concrete_sprite_rect(player, sprite);
        let gl = self.context.gl();

        // Draw red border using WebGL lines
        // Convert to normalized device coordinates
        let width = self.size.0 as f32;
        let height = self.size.1 as f32;

        let left = (rect.left as f32 / width) * 2.0 - 1.0;
        let right = (rect.right as f32 / width) * 2.0 - 1.0;
        let top = 1.0 - (rect.top as f32 / height) * 2.0;
        let bottom = 1.0 - (rect.bottom as f32 / height) * 2.0;

        // Create line vertices for a rectangle
        let vertices: [f32; 16] = [
            left, top,      // top-left
            right, top,     // top-right
            right, top,     // top-right
            right, bottom,  // bottom-right
            right, bottom,  // bottom-right
            left, bottom,   // bottom-left
            left, bottom,   // bottom-left
            left, top,      // back to top-left
        ];

        // Create a VAO to isolate our state changes
        let vao = gl.create_vertex_array().unwrap();
        gl.bind_vertex_array(Some(&vao));

        // Create a simple line shader program if we don't have one
        // For now, use a direct WebGL approach
        let buffer = gl.create_buffer().unwrap();
        gl.bind_buffer(WebGl2RenderingContext::ARRAY_BUFFER, Some(&buffer));

        unsafe {
            let vert_array = js_sys::Float32Array::view(&vertices);
            gl.buffer_data_with_array_buffer_view(
                WebGl2RenderingContext::ARRAY_BUFFER,
                &vert_array,
                WebGl2RenderingContext::STATIC_DRAW,
            );
        }

        // Use a simple shader for colored lines
        let vs_source = "
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        ";
        let fs_source = "
            precision mediump float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        ";

        let vs = gl.create_shader(WebGl2RenderingContext::VERTEX_SHADER).unwrap();
        gl.shader_source(&vs, vs_source);
        gl.compile_shader(&vs);

        let fs = gl.create_shader(WebGl2RenderingContext::FRAGMENT_SHADER).unwrap();
        gl.shader_source(&fs, fs_source);
        gl.compile_shader(&fs);

        let program = gl.create_program().unwrap();
        gl.attach_shader(&program, &vs);
        gl.attach_shader(&program, &fs);
        gl.link_program(&program);
        gl.use_program(Some(&program));

        let pos_loc = gl.get_attrib_location(&program, "a_position") as u32;
        gl.enable_vertex_attrib_array(pos_loc);
        gl.vertex_attrib_pointer_with_i32(pos_loc, 2, WebGl2RenderingContext::FLOAT, false, 0, 0);

        let color_loc = gl.get_uniform_location(&program, "u_color");
        gl.uniform4f(color_loc.as_ref(), 1.0, 0.0, 0.0, 1.0); // Red color

        gl.draw_arrays(WebGl2RenderingContext::LINES, 0, 8);

        // Draw a green pixel at the sprite's loc point
        let loc_x = (sprite.loc_h as f32 / width) * 2.0 - 1.0;
        let loc_y = 1.0 - (sprite.loc_v as f32 / height) * 2.0;

        let point_vertices: [f32; 2] = [loc_x, loc_y];
        unsafe {
            let vert_array = js_sys::Float32Array::view(&point_vertices);
            gl.buffer_data_with_array_buffer_view(
                WebGl2RenderingContext::ARRAY_BUFFER,
                &vert_array,
                WebGl2RenderingContext::STATIC_DRAW,
            );
        }

        gl.uniform4f(color_loc.as_ref(), 0.0, 1.0, 0.0, 1.0); // Green color
        gl.draw_arrays(WebGl2RenderingContext::POINTS, 0, 1);

        // Cleanup - unbind and delete everything to restore state
        gl.bind_vertex_array(None);
        gl.bind_buffer(WebGl2RenderingContext::ARRAY_BUFFER, None);
        gl.use_program(None);

        gl.delete_vertex_array(Some(&vao));
        gl.delete_buffer(Some(&buffer));
        gl.delete_program(Some(&program));
        gl.delete_shader(Some(&vs));
        gl.delete_shader(Some(&fs));
    }

    /// Render a single sprite
    fn render_sprite(&mut self, player: &mut DirPlayer, channel_num: i16) {
        // Get sprite and member info
        let (member_ref, sprite_rect, ink, blend, flip_h, flip_v, rotation, bg_color, fg_color, has_fore_color, has_back_color, is_puppet, raw_loc, sprite_width, sprite_height) = {
            let score = &player.movie.score;
            let sprite = match score.get_sprite(channel_num) {
                Some(s) => s,
                None => return,
            };

            let member_ref = match &sprite.member {
                Some(m) => m.clone(),
                None => return,
            };

            let rect = get_concrete_sprite_rect(player, sprite);
            (
                member_ref,
                rect,
                sprite.ink,
                sprite.blend,
                sprite.flip_h,
                sprite.flip_v,
                sprite.rotation,
                sprite.bg_color.clone(),
                sprite.color.clone(),
                sprite.has_fore_color,
                sprite.has_back_color,
                sprite.puppet,
                (sprite.loc_h, sprite.loc_v),
                sprite.width,
                sprite.height,
            )
        };

        // Determine what kind of texture we need based on member type
        enum TextureSource {
            Bitmap { image_ref: u32 },
            SolidColor { r: u8, g: u8, b: u8 },
            RenderedText {
                cache_key: RenderedTextCacheKey,
                text: String,
                font_name: String,
                font_size: u16,
                font_style: Option<u8>,
                line_spacing: u16,
                top_spacing: i16,
                width: u32,
                height: u32,
                styled_spans: Option<Vec<StyledSpan>>,
                alignment: String,
                word_wrap: bool,
            },
            FilmLoop {
                initial_rect: IntRect,
                width: u32,
                height: u32,
            },
        }

        let texture_source = {
            let member = match player.movie.cast_manager.find_member_by_ref(&member_ref) {
                Some(m) => m,
                None => return,
            };

            match &member.member_type {
                CastMemberType::Bitmap(bitmap_member) => {
                    TextureSource::Bitmap { image_ref: bitmap_member.image_ref }
                }
                CastMemberType::Shape(_shape_member) => {
                    // Skip rendering shapes with tiny dimensions (blank placeholders or zero-size)
                    // Skip if EITHER dimension is <= 1
                    if sprite_width <= 1 || sprite_height <= 1 {
                        return;
                    }

                    // Skip rendering shapes that use member 1:1 - this is a placeholder/empty shape
                    // in Director that shouldn't be rendered visually
                    if member_ref.cast_lib == 1 && member_ref.cast_member == 1 {
                        return;
                    }

                    // Resolve foreground color to RGB
                    let palettes = player.movie.cast_manager.palettes();
                    let (r, g, b) = resolve_color_ref(
                        &palettes,
                        &fg_color,
                        &PaletteRef::BuiltIn(get_system_default_palette()),
                        8, // default bit depth
                    );

                    TextureSource::SolidColor { r, g, b }
                }
                CastMemberType::Font(font_member) => {
                    // Font member: render preview_text using the font
                    let text = &font_member.preview_text;
                    if text.is_empty() {
                        return; // No text to render
                    }

                    // Use sprite rect dimensions for the texture (not measured text)
                    // This prevents stretching when sprite rect differs from text size
                    let width = (sprite_rect.width()).max(1) as u32;
                    let height = (sprite_rect.height()).max(1) as u32;

                    // Get styled spans reference for cache key
                    let styled_spans_ref = if font_member.preview_html_spans.is_empty() {
                        None
                    } else {
                        Some(font_member.preview_html_spans.as_slice())
                    };

                    let cache_key = RenderedTextCacheKey::new_with_styled_spans(
                        member_ref.clone(),
                        text,
                        styled_spans_ref,
                        ink,
                        blend,
                        fg_color.clone(),
                        bg_color.clone(),
                        false,
                        width,
                        height,
                        "left",  // Font members default to left alignment
                        false,   // Font members default to no word wrap
                    );

                    TextureSource::RenderedText {
                        cache_key,
                        text: text.clone(),
                        font_name: font_member.font_info.name.clone(),
                        font_size: font_member.font_info.size,
                        font_style: Some(font_member.font_info.style),
                        line_spacing: font_member.fixed_line_space,
                        top_spacing: font_member.top_spacing,
                        width,
                        height,
                        styled_spans: if font_member.preview_html_spans.is_empty() {
                            None
                        } else {
                            Some(font_member.preview_html_spans.clone())
                        },
                        alignment: "left".to_string(),
                        word_wrap: false,
                    }
                }
                CastMemberType::Text(text_member) => {
                    // Text member: render the text using specified font
                    let text = &text_member.text;
                    if text.is_empty() {
                        return; // No text to render
                    }

                    // Use sprite rect dimensions for the texture (not measured text)
                    // This prevents stretching when sprite rect differs from text size
                    let width = (sprite_rect.width()).max(1) as u32;
                    let height = (sprite_rect.height()).max(1) as u32;

                    // Extract font properties from first styled span if available
                    let (font_name, font_size, font_style) = if !text_member.html_styled_spans.is_empty() {
                        let first_style = &text_member.html_styled_spans[0].style;
                        let name = first_style.font_face.clone().unwrap_or_else(|| text_member.font.clone());
                        let size = first_style.font_size.map(|s| s as u16).unwrap_or(text_member.font_size);
                        // Convert bold/italic/underline to font_style: bit 0 = bold, bit 1 = italic, bit 2 = underline
                        let style = (if first_style.bold { 1u8 } else { 0 })
                            | (if first_style.italic { 2u8 } else { 0 })
                            | (if first_style.underline { 4u8 } else { 0 });
                        (name, size, Some(style))
                    } else {
                        (text_member.font.clone(), text_member.font_size, None)
                    };

                    // Get styled spans reference for cache key
                    let styled_spans_ref = if text_member.html_styled_spans.is_empty() {
                        None
                    } else {
                        Some(text_member.html_styled_spans.as_slice())
                    };

                    let cache_key = RenderedTextCacheKey::new_with_styled_spans(
                        member_ref.clone(),
                        text,
                        styled_spans_ref,
                        ink,
                        blend,
                        fg_color.clone(),
                        bg_color.clone(),
                        false,
                        width,
                        height,
                        &text_member.alignment,
                        text_member.word_wrap,
                    );

                    // Fill in defaults from text_member - ALWAYS apply text_member's current properties
                    // The movie can set font, fontSize, fontStyle at runtime, so these
                    // should override whatever was in the original styled spans
                    let styled_spans_with_defaults: Option<Vec<StyledSpan>> = if text_member.html_styled_spans.is_empty() {
                        None
                    } else {
                        Some(text_member.html_styled_spans.iter().map(|span| {
                            let mut style = span.style.clone();

                            // ALWAYS use text_member's font if set (movie may have changed it)
                            if !text_member.font.is_empty() {
                                style.font_face = Some(text_member.font.clone());
                            } else if style.font_face.as_ref().map_or(true, |f| f.is_empty()) {
                                style.font_face = Some("Arial".to_string());
                            }

                            // ALWAYS use text_member's font_size if set (movie may have changed it)
                            if text_member.font_size > 0 {
                                style.font_size = Some(text_member.font_size as i32);
                            } else if style.font_size.map_or(true, |s| s <= 0) {
                                style.font_size = Some(12);
                            }

                            // Use fg_color if span doesn't have color
                            if style.color.is_none() {
                                style.color = match &fg_color {
                                    ColorRef::Rgb(r, g, b) => {
                                        Some(((*r as u32) << 16) | ((*g as u32) << 8) | (*b as u32))
                                    }
                                    ColorRef::PaletteIndex(idx) => {
                                        match *idx {
                                            0 => Some(0xFFFFFF),
                                            255 => Some(0x000000),
                                            _ => Some(0x000000),
                                        }
                                    }
                                };
                            }

                            // ALWAYS apply text_member's fontStyle (movie may have changed it)
                            if !text_member.font_style.is_empty() {
                                style.bold = text_member.font_style.iter().any(|s| s == "bold");
                                style.italic = text_member.font_style.iter().any(|s| s == "italic");
                                style.underline = text_member.font_style.iter().any(|s| s == "underline");
                            }

                            StyledSpan {
                                text: span.text.clone(),
                                style,
                            }
                        }).collect())
                    };

                    TextureSource::RenderedText {
                        cache_key,
                        text: text.clone(),
                        font_name,
                        font_size,
                        font_style,
                        line_spacing: text_member.fixed_line_space,
                        top_spacing: text_member.top_spacing,
                        width,
                        height,
                        styled_spans: styled_spans_with_defaults,
                        alignment: text_member.alignment.clone(),
                        word_wrap: text_member.word_wrap,
                    }
                }
                CastMemberType::Field(field_member) => {
                    // Field member: editable text field
                    let text = &field_member.text;

                    // Use sprite rect dimensions for the texture (not measured text)
                    // This prevents stretching when sprite rect differs from text size
                    let width = (sprite_rect.width()).max(1) as u32;
                    let height = (sprite_rect.height()).max(1) as u32;

                    // Check if this field has keyboard focus (for cursor rendering)
                    let has_focus = player.keyboard_focus_sprite == channel_num;

                    // Include focus state in cache key so cursor state changes invalidate cache
                    let cache_key = RenderedTextCacheKey::new_with_focus(
                        member_ref.clone(),
                        text,
                        ink,
                        blend,
                        fg_color.clone(),
                        bg_color.clone(),
                        has_focus,
                        width,
                        height,
                    );

                    TextureSource::RenderedText {
                        cache_key,
                        text: text.clone(),
                        font_name: field_member.font.clone(),
                        font_size: field_member.font_size,
                        font_style: None,
                        line_spacing: field_member.fixed_line_space,
                        top_spacing: field_member.top_spacing,
                        width,
                        height,
                        styled_spans: None,
                        alignment: field_member.alignment.clone(),
                        word_wrap: field_member.word_wrap,
                    }
                }
                CastMemberType::FilmLoop(film_loop) => {
                    // Film loop: render the film loop's score to an offscreen bitmap
                    // The film loop's rect is stored in info as:
                    // - reg_point = (left, top) coordinates of the rect
                    // - width = right coordinate
                    // - height = bottom coordinate
                    let info_rect_left = film_loop.info.reg_point.0 as i32;
                    let info_rect_top = film_loop.info.reg_point.1 as i32;
                    let info_rect_right = film_loop.info.width as i32;
                    let info_rect_bottom = film_loop.info.height as i32;
                    let initial_rect = IntRect::from(info_rect_left, info_rect_top, info_rect_right, info_rect_bottom);

                    // Store just the metadata - we'll render after this block ends
                    let width = initial_rect.width().max(1);
                    let height = initial_rect.height().max(1);

                    TextureSource::FilmLoop {
                        initial_rect,
                        width: width as u32,
                        height: height as u32,
                    }
                }
                _ => {
                    // Unhandled member types are silently skipped
                    return;
                }
            }
        };

        // Get bitmap info for palette reference, bit depth, and use_alpha (only used for bitmap sprites)
        let (bitmap_palette_ref, bitmap_bit_depth, bitmap_use_alpha) = match &texture_source {
            TextureSource::Bitmap { image_ref } => {
                match player.bitmap_manager.get_bitmap(*image_ref) {
                    Some(bitmap) => {
                        (bitmap.palette_ref.clone(), bitmap.original_bit_depth, bitmap.use_alpha)
                    }
                    None => (PaletteRef::BuiltIn(get_system_default_palette()), 8, false),
                }
            }
            TextureSource::SolidColor { .. } => {
                // Solid colors use system default palette, no alpha
                (PaletteRef::BuiltIn(get_system_default_palette()), 8, false)
            }
            TextureSource::RenderedText { .. } => {
                // Rendered text uses 32-bit RGBA with alpha for transparent background
                (PaletteRef::BuiltIn(get_system_default_palette()), 32, true)
            }
            TextureSource::FilmLoop { .. } => {
                // Film loops are rendered as 32-bit RGBA with alpha
                (PaletteRef::BuiltIn(get_system_default_palette()), 32, true)
            }
        };

        // Resolve colors to RGB for shader uniforms and colorize
        let palettes = player.movie.cast_manager.palettes();
        // Sprite foreColor/backColor palette indices are resolved against the bitmap's palette,
        // so they work together correctly (e.g., index 248/255 in a custom 256-color palette).
        // Director behavior: for 32-bit bitmaps without use_alpha and ink != 0,
        // palette indices are ignored for bgColor and white (255,255,255) is used instead.
        // This matches Canvas2D behavior in drawing.rs lines 780-795.
        let bg_color_rgb = if bitmap_bit_depth == 32 && !bitmap_use_alpha && ink != 0 {
            match &bg_color {
                ColorRef::Rgb(r, g, b) => (*r, *g, *b),
                ColorRef::PaletteIndex(_) => (255, 255, 255),
            }
        } else {
            resolve_color_ref(
                &palettes,
                &bg_color,
                &bitmap_palette_ref,
                bitmap_bit_depth,
            )
        };
        let fg_color_rgb = resolve_color_ref(
            &palettes,
            &fg_color,
            &bitmap_palette_ref,
            bitmap_bit_depth,
        );

        // Build colorize parameters if colorize is active
        // - For 1-bit bitmaps with ink 0 or 36: ALWAYS apply foreColor/bgColor
        //   (Director behavior - 1-bit bitmaps always use sprite colors)
        // - For 2-8 bit indexed bitmaps: only colorize if has_fore_color or has_back_color is set via Lingo
        // - For 32-bit bitmaps with ink 0, 8, 9: general colorize (requires has_fore_color or has_back_color)
        // - For indexed bitmaps with ink 36: foreColor tinting for monochrome-style bitmaps
        // Note: Ink 40 does NOT use foreColor tinting - it just uses color-key transparency
        let is_indexed = bitmap_bit_depth >= 1 && bitmap_bit_depth <= 8;
        let is_ink36_indexed = is_indexed && ink == 36;

        let colorize_params = if bitmap_bit_depth == 1 && (ink == 0 || ink == 36) {
            // 1-bit bitmaps with ink 0: ALWAYS apply foreColor/bgColor
            // This is Director behavior - 1-bit bitmaps always use sprite colors
            Some((
                true, // has_fore is always true for 1-bit bitmaps
                true, // has_back is always true for 1-bit bitmaps
                fg_color_rgb.0,
                fg_color_rgb.1,
                fg_color_rgb.2,
                bg_color_rgb.0,
                bg_color_rgb.1,
                bg_color_rgb.2,
            ))
        } else if is_ink36_indexed {
            // Ink 36 indexed: ALWAYS apply foreColor to foreground pixels (index 255 or black)
            // This matches drawing.rs behavior where fg_color_resolved is always used
            // Note: Ink 40 does NOT apply foreColor tinting - it just skips bgColor pixels
            Some((
                true, // has_fore is always true for ink 36 indexed
                true, // has_back is always true for ink 36 indexed
                fg_color_rgb.0,
                fg_color_rgb.1,
                fg_color_rgb.2,
                bg_color_rgb.0,
                bg_color_rgb.1,
                bg_color_rgb.2,
            ))
        } else if (has_fore_color || has_back_color) && (
            // 32-bit colorize (ink 0, 8, 9)
            (bitmap_bit_depth == 32 && (ink == 0 || ink == 8 || ink == 9))
        ) {
            Some((
                has_fore_color,
                has_back_color,
                fg_color_rgb.0,
                fg_color_rgb.1,
                fg_color_rgb.2,
                bg_color_rgb.0,
                bg_color_rgb.1,
                bg_color_rgb.2,
            ))
        } else {
            None
        };

        // Get or create texture based on source type
        // For bitmaps, pass the ink so the texture has the correct matte mask baked in
        // For ink 8, we pass sprite's bgColor for matte computation
        // (this matches Canvas2D's copy_pixels_with_params which uses sprite bgColor)
        // Note: Ink 33 uses shader color-key, not texture matte
        // Colorize is also baked into the texture when has_fore_color or has_back_color is set

        let tex = match texture_source {
            TextureSource::Bitmap { image_ref } => {
                // For inks 7, 8, 9, 40, and 41, pass sprite's bgColor for matte/transparency computation
                // - Ink 7: uses bgColor for matte (not ghost - skips bgColor pixels)
                // - Ink 8: always uses bgColor for matte
                // - Ink 9: uses bgColor for 32-bit bitmaps
                // - Ink 40: uses bgColor for transparency (lighten - skips bgColor pixels)
                // - Ink 41: uses bgColor for 32-bit bitmaps, palette index 0 for indexed
                let sprite_bg_for_matte = if ink == 7 || ink == 8 || ink == 9 || ink == 40 || ink == 41 { Some(bg_color_rgb) } else { None };

                match self.get_or_create_texture(player, &member_ref, image_ref, ink, colorize_params, sprite_bg_for_matte) {
                    Some((tex, _w, _h)) => tex,
                    None => return,
                }
            }
            TextureSource::SolidColor { r, g, b } => {
                self.get_or_create_solid_color_texture(r, g, b)
            }
            TextureSource::RenderedText {
                ref cache_key,
                ref text,
                ref font_name,
                font_size,
                font_style,
                line_spacing,
                top_spacing,
                width,
                height,
                ref styled_spans,
                ref alignment,
                word_wrap,
            } => {
                // Check cache first
                if let Some(cached) = self.rendered_text_cache.get(cache_key) {
                    cached.texture.clone()
                } else {
                    // Render text to a bitmap and upload as texture
                    match self.render_text_to_texture(
                        player,
                        cache_key,
                        text,
                        font_name,
                        font_size,
                        font_style,
                        line_spacing,
                        top_spacing,
                        width,
                        height,
                        ink,
                        blend,
                        &fg_color,
                        &bg_color,
                        styled_spans.as_ref(),
                        alignment,
                        word_wrap,
                    ) {
                        Some(tex) => tex,
                        None => return,
                    }
                }
            }
            TextureSource::FilmLoop { initial_rect, width, height } => {
                // Render the film loop's score to an offscreen bitmap
                let mut filmloop_bitmap = Bitmap::new(
                    width as u16,
                    height as u16,
                    32,
                    32,
                    8, // alpha_depth = 8 for transparency support
                    PaletteRef::BuiltIn(get_system_default_palette()),
                );
                // Enable alpha channel for filmloop transparency
                filmloop_bitmap.use_alpha = true;
                // Clear to fully transparent (RGBA 0,0,0,0) so only rendered sprites are visible
                filmloop_bitmap.data.fill(0);

                // Render the film loop's score to the offscreen bitmap
                render_score_to_bitmap_with_offset(
                    player,
                    &ScoreRef::FilmLoop(member_ref.clone()),
                    &mut filmloop_bitmap,
                    None, // debug_sprite_num
                    IntRect::from_size(0, 0, width as i32, height as i32),
                    (initial_rect.left, initial_rect.top),
                    Some(FilmLoopParentProps {
                        ink: ink as u32,
                        color: fg_color.clone(),
                        bg_color: bg_color.clone(),
                    }),
                );

                // Upload the filmloop bitmap as a texture
                let texture = match self.context.create_texture() {
                    Ok(t) => t,
                    Err(_) => return,
                };
                if self.context.upload_texture_rgba(&texture, width, height, &filmloop_bitmap.data).is_err() {
                    return;
                }
                texture
            }
        };

        // Select shader based on ink mode
        // The bgColor-based transparency is now baked into the texture's alpha channel
        // via the flood-fill matte mask computation, so we use the ink mode directly
        let ink_mode = InkMode::from_ink_number(ink);
        // use_program returns the effective ink mode (after fallback if needed)
        let effective_ink = self.shader_manager.use_program(&self.context, ink_mode);

        // Get the active program's uniform locations (use effective_ink to ensure consistency)
        let program = match self.shader_manager.get_program(effective_ink) {
            Some(p) => p,
            None => return,
        };
        let u_projection = program.u_projection.clone();
        let u_texture = program.u_texture.clone();
        let u_sprite_rect = program.u_sprite_rect.clone();
        let u_tex_rect = program.u_tex_rect.clone();
        let u_flip = program.u_flip.clone();
        let u_rotation = program.u_rotation.clone();
        let u_rotation_center = program.u_rotation_center.clone();
        let u_blend = program.u_blend.clone();
        let u_bg_color = program.u_bg_color.clone();
        let u_color_tolerance = program.u_color_tolerance.clone();

        // Set blend mode based on effective ink (to match the shader being used)
        match effective_ink {
            InkMode::AddPin => {
                self.context.set_blend_additive();
            }
            InkMode::SubPin => {
                // SubPin uses reverse subtract: result = dst - src
                self.context.set_blend_subtractive();
            }
            InkMode::Darken => {
                // Darken uses standard alpha blending
                // The shader multiplies src by bgColor, then we alpha-blend the result
                self.context.set_blend_alpha();
            }
            InkMode::Lighten => {
                // Lighten in Director: skip bgColor pixels, blend others normally
                // This is NOT max(src, dst) - it's just normal alpha blending
                // with transparency for bgColor pixels (baked into texture alpha)
                self.context.set_blend_alpha();
            }
            _ => self.context.set_blend_alpha(),
        }

        // Now we can get gl reference and set uniforms
        let gl = self.context.gl();

        // Set projection matrix
        if let Some(ref loc) = u_projection {
            gl.uniform_matrix4fv_with_f32_array(Some(loc), false, &self.projection_matrix);
        }

        // Bind texture
        gl.active_texture(WebGl2RenderingContext::TEXTURE0);
        gl.bind_texture(WebGl2RenderingContext::TEXTURE_2D, Some(&tex));
        if let Some(ref loc) = u_texture {
            gl.uniform1i(Some(loc), 0);
        }

        // Set sprite rect uniform (x, y, width, height)
        if let Some(ref loc) = u_sprite_rect {
            gl.uniform4f(
                Some(loc),
                sprite_rect.left as f32,
                sprite_rect.top as f32,
                sprite_rect.width() as f32,
                sprite_rect.height() as f32,
            );
        }

        // Set texture rect (full texture for now)
        if let Some(ref loc) = u_tex_rect {
            gl.uniform4f(Some(loc), 0.0, 0.0, 1.0, 1.0);
        }

        // Set flip
        if let Some(ref loc) = u_flip {
            gl.uniform2f(
                Some(loc),
                if flip_h { 1.0 } else { 0.0 },
                if flip_v { 1.0 } else { 0.0 },
            );
        }

        // Set rotation (convert degrees to radians)
        // Note: drawing.rs negates for inverse rotation (dst->src mapping),
        // but WebGL does forward rotation (vertex transformation), so no negation needed
        if let Some(ref loc) = u_rotation {
            gl.uniform1f(Some(loc), (rotation as f32).to_radians());
        }

        // Set rotation center (sprite's registration point: loc_h, loc_v)
        if let Some(ref loc) = u_rotation_center {
            gl.uniform2f(Some(loc), raw_loc.0 as f32, raw_loc.1 as f32);
        }

        // Set blend (0-100 -> 0.0-1.0)
        if let Some(ref loc) = u_blend {
            gl.uniform1f(Some(loc), blend as f32 / 100.0);
        }

        // Set background color for ink modes that need it:
        // - BackgroundTransparent: for color-key transparency
        // - NotGhost: for color-key transparency
        // - Darken: for src * bg_color multiplication
        // - AddPin: for color-key transparency (ALL bgColor pixels transparent)
        // - SubPin: for color-key transparency (ALL bgColor pixels transparent)
        // Note: Matte (ink 8) uses flood-fill matte in texture alpha, not color-key
        // (using the already-resolved bg_color_rgb from earlier)
        if effective_ink == InkMode::BackgroundTransparent
            || effective_ink == InkMode::NotGhost
            || effective_ink == InkMode::Darken
            || effective_ink == InkMode::AddPin
            || effective_ink == InkMode::SubPin
            || effective_ink == InkMode::Lighten
        {
            if let Some(ref loc) = u_bg_color {
                gl.uniform4f(
                    Some(loc),
                    bg_color_rgb.0 as f32 / 255.0,
                    bg_color_rgb.1 as f32 / 255.0,
                    bg_color_rgb.2 as f32 / 255.0,
                    1.0,
                );
            }
            if let Some(ref loc) = u_color_tolerance {
                // For 1-bit bitmaps: transparency is baked into texture alpha via is_1bit_transparent
                // For indexed ink 40 (2-8 bit): transparency is baked via RGB comparison with sprite's bgColor
                // In both cases, disable shader color-key by setting tolerance to 0.
                // For 16-bit and 32-bit: use small tolerance for floating-point RGB comparison.
                let is_indexed_ink40 = bitmap_bit_depth >= 2 && bitmap_bit_depth <= 8 && ink == 40;
                let tolerance = if bitmap_bit_depth == 1 || is_indexed_ink40 { 0.0 } else { 0.01 };
                gl.uniform1f(Some(loc), tolerance);
            }
        }

        // Draw the quad
        self.quad.draw(gl);

        // Unbind texture
        gl.bind_texture(WebGl2RenderingContext::TEXTURE_2D, None);

        // Reset blend equation if we used SubPin (which changes the blend equation to REVERSE_SUBTRACT)
        // Note: Lighten now uses normal alpha blend, not MAX
        if effective_ink == InkMode::SubPin {
            self.context.reset_blend_equation();
        }
    }

    /// Convert bitmap data to RGBA format for GPU texture upload
    ///
    /// For bitmaps without explicit matte, computes a flood-fill matte mask from edges
    /// using the bitmap's intrinsic background color (palette index 0 for indexed bitmaps,
    /// white for 32-bit). This matches Director's behavior where the matte is computed
    /// once per bitmap based on its own palette, not the sprite's bgColor.
    ///
    /// For indexed bitmaps, we compare palette INDICES (not RGB values) to match
    /// how Canvas2D's create_matte works. This ensures that only pixels with exactly
    /// palette index 0 are considered background, not pixels that happen to have the
    /// same RGB color at a different palette index.
    ///
    /// Colorize parameters: (has_fore, has_back, fg_r, fg_g, fg_b, bg_r, bg_g, bg_b)
    /// sprite_bg_color: The sprite's bgColor, used for ink 8 matte computation on indexed bitmaps
    fn bitmap_to_rgba(
        bitmap: &Bitmap,
        palettes: &crate::player::bitmap::palette_map::PaletteMap,
        ink: i32,
        colorize: Option<(bool, bool, u8, u8, u8, u8, u8, u8)>,
        sprite_bg_color: Option<(u8, u8, u8)>,
    ) -> Vec<u8> {
        let width = bitmap.width as usize;
        let height = bitmap.height as usize;
        let mut rgba_data = Vec::with_capacity(width * height * 4);

        // Extract colorize info if present
        let (has_fore, has_back, fg_rgb, bg_rgb) = match colorize {
            Some((has_f, has_b, fg_r, fg_g, fg_b, bg_r, bg_g, bg_b)) => {
                (has_f, has_b, (fg_r, fg_g, fg_b), (bg_r, bg_g, bg_b))
            }
            None => (false, false, (0, 0, 0), (255, 255, 255)),
        };

        // Check if colorize should be applied
        // Matches drawing.rs allows_colorize() function (lines 750-762)
        // EXCEPTION: ink 36 indexed has special foreColor tinting (drawing.rs lines 1188-1196)
        //   For ink 36 indexed, foreColor is ALWAYS applied to foreground pixels (index 255 or black),
        //   regardless of has_fore_color flag - this is Director behavior.
        // Note: Ink 40 does NOT use colorization - it only uses color-key transparency
        let allow_colorize = match (bitmap.original_bit_depth, ink as u32) {
            (32, 0) => true,                    // 32-bit ink 0: grayscale remap
            (32, 8) | (32, 9) => true,          // 32-bit ink 8/9: foreColor only
            (d, 0) if d <= 8 => true,           // indexed ink 0: palette index interpolation
            (d, 8) | (d, 9) if d <= 8 => true,  // indexed ink 8/9: foreColor only
            (d, 36) if d <= 8 => true,          // indexed ink 36: foreColor tinting for index 255/black (ALWAYS)
            _ => false,
        };

        // Special flag for ink 36 indexed foreColor tinting
        // For ink 36 indexed, ALWAYS tint foreground pixels with foreColor (has_fore is always true)
        let ink36_indexed_tint = bitmap.original_bit_depth <= 8 && ink == 36;

        // Check if backColor should be used (for interpolation)
        let use_back_color = match (bitmap.original_bit_depth, ink as u32) {
            (32, 0) => true,
            (d, 0) if d <= 8 => true,
            _ => false,
        };

        // Compute flood-fill matte from edges for bitmaps without explicit matte.
        //
        // Director behavior for matte:
        // - Ink 0 (Copy): use matte ONLY when trim_white_space is true
        // - Ink 8 (Matte): ALWAYS use matte (this is the "matte" ink, its whole purpose is transparency)
        //
        // For ink 8, the pre-computed bitmap.matte should be used (created by rendering.rs).
        // If bitmap.matte doesn't exist, we compute it here.
        //
        // Bit depth support:
        // - Indexed bitmaps (depth <= 8): use matte for ink 0 (when trim_white_space) and ink 8 (always)
        // - 16-bit bitmaps: use matte for ink 0 only (when trim_white_space)
        // - 32-bit bitmaps with use_alpha=false: use flood-fill matte for ink 0/8
        // - 32-bit bitmaps with use_alpha=true: use embedded alpha channel (no matte)
        //
        // IMPORTANT: Use original_bit_depth for these checks because bit_depth can change
        // during execution (e.g., 4-bit stored as 8-bit), but original_bit_depth reliably
        // indicates when palette colors should be applied.
        let is_indexed = bitmap.original_bit_depth > 0 && bitmap.original_bit_depth <= 8;
        let is_16bit = bitmap.original_bit_depth == 16;
        let is_32bit = bitmap.original_bit_depth == 32;

        let is_grayscale = matches!(&bitmap.palette_ref, crate::player::bitmap::bitmap::PaletteRef::BuiltIn(
            crate::player::bitmap::bitmap::BuiltInPalette::GrayScale
        ));

        // Determine when to use matte based on ink mode:
        //
        // Matte mask usage for indexed bitmaps in score sprite rendering:
        // - Ink 0: matte when trim_white_space is true
        // - Ink 7 (Not Ghost): use matte for indexed bitmaps (flood-fill, not color-key)
        // - Ink 8 (Matte): ALWAYS use matte (flood-fill transparency)
        // - Ink 9 (Mask): use matte for 32-bit bitmaps (embedded alpha or grayscale-as-alpha)
        // - Ink 41 (Darken): use matte for indexed and 32-bit bitmaps
        //
        // Important: some inks use color-key transparency in the shader instead of matte:
        // - Ink 33 (Add Pin): color-key comparison in shader
        // - Ink 36 (BgTransparent): color-key comparison in shader
        let should_use_matte_ink0 = bitmap.trim_white_space && ink == 0;
        // Ink 7 (Not Ghost) uses matte for indexed and 16-bit bitmaps (flood-fill from edges)
        // This matches Canvas2D's should_matte_sprite which includes ink 7
        let should_use_matte_ink7 = ink == 7 && (is_indexed || is_16bit);
        // Ink 8 (Matte) ALWAYS uses matte for indexed, 16-bit, and 32-bit bitmaps in score rendering
        // The flood-fill matte makes edge-connected background pixels transparent
        // while keeping interior pixels (even if same color) opaque
        // For 32-bit, only applies when use_alpha is false (otherwise embedded alpha is used)
        let should_use_matte_ink8 = ink == 8 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));
        // Ink 9 (Mask) uses matte for 32-bit bitmaps (embedded alpha like ink 8)
        let should_use_matte_ink9 = ink == 9 && (is_32bit && !bitmap.use_alpha);
        // Ink 41 (Darken) uses matte for indexed, 16-bit, and 32-bit bitmaps
        // Background pixels should be transparent so they don't darken the destination
        // For indexed: use palette index 0
        // For 16-bit/32-bit: use RGB comparison with bgColor (typically white)
        let should_use_matte_ink41 = ink == 41 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));
        // Ink 33 (Add Pin) uses COLOR-KEY transparency (ALL bgColor pixels transparent)
        // NOT flood-fill matte. See drawing.rs lines 160-163: if src == bg_color { dst }
        // Color-key comparison is handled in the shader, not texture matte.
        // For 16-bit and 32-bit, the shader compares pixel RGB with bgColor uniform.
        let should_use_colorkey_ink33 = ink == 33 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));
        // Ink 35 (Sub Pin) uses COLOR-KEY transparency (ALL bgColor pixels transparent)
        // Same behavior as ink 33 but with subtractive blending
        let should_use_colorkey_ink35 = ink == 35 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));
        // Ink 36 uses color-key transparency for indexed (2-8 bit), 16-bit, and 32-bit bitmaps (not flood-fill)
        // EXCEPTION: 1-bit bitmaps already have alpha baked into texture via is_1bit_transparent,
        // so they don't need shader color-key (which would incorrectly discard colorized pixels)
        // See drawing.rs lines 1210-1231 for 16-bit ink 36 handling
        // See drawing.rs lines 1421-1437 for 32-bit ink 36 handling
        let is_indexed_not_1bit = bitmap.original_bit_depth >= 2 && bitmap.original_bit_depth <= 8;
        let should_use_colorkey_ink36 = ink == 36 && (is_indexed_not_1bit || is_16bit || (is_32bit && !bitmap.use_alpha));
        // Ink 40 (Lighten) uses color-key transparency: skip bgColor pixels
        // For indexed bitmaps: use palette index comparison in texture (baked alpha)
        // For 16-bit and 32-bit: use RGB color-key in shader
        let should_use_colorkey_ink40 = ink == 40 && (is_16bit || (is_32bit && !bitmap.use_alpha));
        // For indexed ink 40, we bake transparency based on palette index
        let is_ink40_indexed_transparent = ink == 40 && is_indexed_not_1bit;
        // Total: when to use matte (either pre-computed or on-the-fly)
        // Note: ink 33 uses color-key in shader, NOT matte
        let should_use_matte = should_use_matte_ink0 || should_use_matte_ink7 || should_use_matte_ink8 || should_use_matte_ink9 || should_use_matte_ink41;

        // For ink 7, 8, 9, and 41, ALWAYS compute matte (flood-fill from edges)
        // This matches score rendering behavior where these inks use matte
        // The matte makes edge-connected background transparent while keeping interior pixels opaque
        //
        // For ink 0, only compute matte when trim_white_space is true
        // Note: Ink 33 does NOT use flood-fill matte - it uses shader color-key
        let is_matte_bitmap = bitmap.trim_white_space;
        let ink_7_needs_matte = ink == 7 && (is_indexed || is_16bit);
        let ink_8_needs_matte = ink == 8 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));
        let ink_9_needs_matte = ink == 9 && (is_32bit && !bitmap.use_alpha);
        let ink_41_needs_matte = ink == 41 && (is_indexed || is_16bit || (is_32bit && !bitmap.use_alpha));

        let needs_computed_matte = (bitmap.matte.is_none() || ink_7_needs_matte || ink_8_needs_matte || ink_9_needs_matte || ink_41_needs_matte)
            && should_use_matte
            && width > 0
            && height > 0
            && (
                // Indexed bitmaps ink 0: matte only when trim_white_space
                (is_indexed && is_matte_bitmap && ink == 0)
                // Indexed bitmaps ink 7: ALWAYS use matte (flood-fill, not color-key)
                || (is_indexed && ink == 7)
                // Indexed bitmaps ink 8: ALWAYS use matte (flood-fill transparency)
                || (is_indexed && ink == 8)
                // Indexed bitmaps ink 41: ALWAYS use matte (background shouldn't darken)
                || (is_indexed && ink == 41)
                // 16-bit bitmaps ink 0: matte only when trim_white_space
                || (is_16bit && should_use_matte_ink0)
                // 16-bit bitmaps ink 7: ALWAYS use matte (flood-fill, not color-key)
                || (is_16bit && ink == 7)
                // 16-bit bitmaps ink 8: ALWAYS use matte (flood-fill transparency)
                || (is_16bit && ink == 8)
                // 16-bit bitmaps ink 41: ALWAYS use matte (background shouldn't darken)
                || (is_16bit && ink == 41)
                // 32-bit bitmaps WITHOUT use_alpha ink 0: matte only when trim_white_space
                || (is_32bit && !bitmap.use_alpha && is_matte_bitmap && ink == 0)
                // 32-bit bitmaps WITHOUT use_alpha ink 8: ALWAYS use matte (flood-fill transparency)
                || (is_32bit && !bitmap.use_alpha && ink == 8)
                // 32-bit bitmaps WITHOUT use_alpha ink 9: ALWAYS use matte (embedded alpha)
                || (is_32bit && !bitmap.use_alpha && ink == 9)
                // 32-bit bitmaps WITHOUT use_alpha ink 41: ALWAYS use matte with bgColor
                || (is_32bit && !bitmap.use_alpha && ink == 41)
            );

        // Compute matte mask
        let computed_matte: Option<Vec<bool>> = if needs_computed_matte {
            if is_indexed {
                // For indexed bitmaps:
                // - Ink 7 (Not Ghost): use RGB comparison with sprite's bgColor
                //   This ink makes edge-connected bgColor pixels transparent (skips bgColor pixels)
                // - Ink 8 (Matte): use RGB comparison with sprite's bgColor
                //   This ink makes edge-connected bgColor pixels transparent via flood-fill
                // - Ink 41 (Darken): use palette index 0 comparison (standard matte)
                //   The bgColor is used for color multiplication in the shader, not for matte
                // - Other inks: use palette index 0 comparison (like bitmap.matte / create_matte())
                //   This matches Director's standard behavior where index 0 is background.
                // Note: Ink 33 uses shader color-key, NOT flood-fill matte
                if ink == 7 || ink == 8 {
                    // Ink 7 and 8: use RGB comparison with sprite's bgColor (matches Canvas2D behavior)
                    // Canvas2D uses sprite's bgColor as the background color for flood-fill matte,
                    // NOT the edge pixel color. This is critical for bitmaps with borders.
                    // If sprite_bg_color is not provided, fall back to edge pixel color.
                    let bg_color_for_matte = sprite_bg_color.unwrap_or_else(|| {
                        bitmap.get_pixel_color(palettes, 0, 0)
                    });

                    Some(Self::compute_edge_matte_mask_rgb(bitmap, palettes, bg_color_for_matte, width, height))
                } else {
                    // Ink 41 and other inks: use palette index comparison (background = index 0)
                    Some(Self::compute_edge_matte_mask_indexed(bitmap, width, height))
                }
            } else if is_32bit {
                // For 32-bit bitmaps without use_alpha:
                // - Ink 8: use sprite's bgColor for matte (matches Canvas2D behavior)
                // - Ink 9: use sprite's bgColor for matte (mask ink uses bgColor for transparency)
                // - Ink 41: use sprite's bgColor for matte (typically white for transparency)
                // - Other inks: use edge color (matching drawing.rs lines 891-897)
                let bg_color_for_matte = if ink == 8 || ink == 9 || ink == 41 {
                    sprite_bg_color.unwrap_or_else(|| bitmap.get_pixel_color(palettes, 0, 0))
                } else {
                    bitmap.get_pixel_color(palettes, 0, 0)
                };
                Some(Self::compute_edge_matte_mask_rgb(bitmap, palettes, bg_color_for_matte, width, height))
            } else if is_16bit {
                // For 16-bit bitmaps:
                // - Ink 7, 8, 41: use sprite's bgColor for matte (matches Canvas2D behavior)
                // - Ink 0: use white as background (default for trim_white_space)
                let bg_color_for_matte = if ink == 7 || ink == 8 || ink == 41 {
                    sprite_bg_color.unwrap_or((255u8, 255u8, 255u8))
                } else {
                    (255u8, 255u8, 255u8)
                };
                Some(Self::compute_edge_matte_mask_rgb(bitmap, palettes, bg_color_for_matte, width, height))
            } else {
                None
            }
        } else {
            None
        };

        let mut opaque_count = 0usize;
        let mut transparent_count = 0usize;

        // Check if this is a 32-bit bitmap with embedded alpha (use_alpha=true)
        // These should use embedded alpha, ignoring any matte that may have been computed
        // Use original_bit_depth since bit_depth can change during execution
        let use_embedded_alpha = bitmap.original_bit_depth == 32 && bitmap.use_alpha;

        for y in 0..height {
            for x in 0..width {
                let (r, g, b) = bitmap.get_pixel_color(palettes, x as u16, y as u16);

                // Get alpha:
                // 1. For 32-bit bitmaps with use_alpha=true, ALWAYS use embedded alpha
                // 2. For ink 36 (BgTransparent) with indexed bitmaps: color-key (index 0 = transparent)
                // 3. For ink 8 (Matte) and other flood-fill inks: use matte
                // 4. For ink 0 with trim_white_space: use matte
                // 5. For other 32-bit bitmaps (use_alpha=false, no matte): use embedded alpha
                // 6. For other bitmaps: fully opaque
                //
                // Special handling for 1-bit bitmaps (all inks except ink 0):
                // Index 0 (bit=0) = background  transparent
                // Index 1/255 (bit=1) = foreground  opaque (color handled in colorize section)
                let is_1bit_transparent = if bitmap.original_bit_depth == 1 && ink != 0 {
                    let color_ref = bitmap.get_pixel_color_ref(x as u16, y as u16);
                    if let ColorRef::PaletteIndex(i) = color_ref {
                        i == 0 // Index 0 = background = transparent
                    } else {
                        false
                    }
                } else {
                    false
                };

                // Special handling for ink 40 indexed bitmaps (2-8 bit):
                // Compare RGB against sprite's bgColor (like drawing.rs lines 203-209)
                // This matches Canvas2D: if src == bg_color, skip (transparent)
                let is_ink40_indexed_bg = if is_ink40_indexed_transparent {
                    if let Some(bg_color) = sprite_bg_color {
                        // Compare this pixel's RGB against sprite's bgColor
                        (r, g, b) == bg_color
                    } else {
                        false
                    }
                } else {
                    false
                };

                let a = if is_1bit_transparent || is_ink40_indexed_bg {
                    // 1-bit or ink 40 indexed background pixel  transparent
                    0
                } else if ink == 0 && use_embedded_alpha {
                    // For 32-bit bitmaps with ink 0 (Copy) and use_alpha=true: use embedded alpha
                    let index = (y * width + x) * 4;
                    if index + 3 < bitmap.data.len() {
                        bitmap.data[index + 3]
                    } else {
                        255
                    }
                } else if ink == 0 {
                    // For ink 0 (Copy) without use_alpha: always fully opaque
                    // This applies to indexed, 16-bit, and 32-bit with use_alpha=false
                    255
                } else if use_embedded_alpha {
                    // 32-bit with use_alpha (non-ink-0): use embedded alpha directly, ignore any matte
                    let index = (y * width + x) * 4;
                    if index + 3 < bitmap.data.len() {
                        bitmap.data[index + 3]
                    } else {
                        255
                    }
                } else if should_use_colorkey_ink33 || should_use_colorkey_ink35 || should_use_colorkey_ink36 {
                    // Ink 33/35/36 color-key transparency is handled by shader
                    // The shader compares pixel RGB with bgColor uniform
                    // All pixels are uploaded as opaque, shader discards matching pixels
                    // Works for indexed (2-8 bit), 16-bit, and 32-bit (without use_alpha) bitmaps
                    // Note: 1-bit bitmaps are excluded - they use is_1bit_transparent for alpha instead
                    255
                } else if should_use_matte {
                    // Use matte for inks 0 and 8 when trim_white_space is true
                    if let Some(ref computed) = computed_matte {
                        // Use computed flood-fill matte
                        if computed[y * width + x] { 255 } else { 0 }
                    } else if let Some(ref matte) = bitmap.matte {
                        // Use pre-computed bitmap.matte
                        if matte.get_bit(x as u16, y as u16) { 255 } else { 0 }
                    } else {
                        255 // No matte available, fully opaque
                    }
                } else if bitmap.original_bit_depth == 32 && !bitmap.use_alpha {
                    // For 32-bit bitmaps with use_alpha=false and ink 0 (Copy):
                    // Pixels are fully opaque (matching drawing.rs lines 1366-1367)
                    // The embedded alpha is ignored when use_alpha is false
                    255
                } else {
                    // For other bitmaps without matte conditions, all pixels are opaque
                    255
                };

                // Apply colorize if enabled (only when has_fore_color or has_back_color is explicitly set)
                // Matching drawing.rs lines 1304-1326 for indexed and lines 1283-1301 for 32-bit
                let (final_r, final_g, final_b) = if allow_colorize && (has_fore || has_back) {
                    match bitmap.original_bit_depth {
                        // ---------- 32-BIT ----------
                        32 => {
                            // Treat source as grayscale intensity
                            let gray = ((r as u16 + g as u16 + b as u16) / 3) as u8;

                            if has_fore && has_back && use_back_color {
                                // Interpolate between fg and bg based on gray
                                let t = gray as f32 / 255.0;
                                (
                                    ((1.0 - t) * fg_rgb.0 as f32 + t * bg_rgb.0 as f32) as u8,
                                    ((1.0 - t) * fg_rgb.1 as f32 + t * bg_rgb.1 as f32) as u8,
                                    ((1.0 - t) * fg_rgb.2 as f32 + t * bg_rgb.2 as f32) as u8,
                                )
                            } else if has_fore && gray <= 1 {
                                // Replace near-black with fg color
                                fg_rgb
                            } else {
                                (r, g, b)
                            }
                        }

                        // ---------- 1-BIT BITMAPS ----------
                        1 => {
                            // For 1-bit bitmaps with ink 0 or 36:
                            // - foreground (index 255, bit=1)  foreColor
                            // - background (index 0, bit=0)  bgColor (ink 0) or transparent (ink 36)
                            // Note: 1-bit bitmaps store indices as 0 and 255 (not 0 and 1)
                            let color_ref = bitmap.get_pixel_color_ref(x as u16, y as u16);
                            if let ColorRef::PaletteIndex(i) = color_ref {
                                if i != 0 {
                                    // Foreground bit (index 255)  use foreColor
                                    if has_fore {
                                        fg_rgb
                                    } else {
                                        (r, g, b)
                                    }
                                } else {
                                    // Background bit (index 0)  use bgColor
                                    if has_back && use_back_color {
                                        bg_rgb
                                    } else {
                                        (r, g, b)
                                    }
                                }
                            } else {
                                (r, g, b)
                            }
                        }

                        // ---------- INDEXED (2-8 bit) ----------
                        _ => {
                            // Get palette index
                            let color_ref = bitmap.get_pixel_color_ref(x as u16, y as u16);

                            if let ColorRef::PaletteIndex(i) = color_ref {
                                // Ink 36 special case: foreColor tinting for monochrome-style bitmaps
                                // See drawing.rs lines 1172-1176: index 255 or black pixels get foreColor
                                // Note: Ink 40 does NOT apply foreColor tinting - it just uses color-key transparency
                                if ink36_indexed_tint {
                                    if i == 255 || (r == 0 && g == 0 && b == 0) {
                                        fg_rgb
                                    } else {
                                        (r, g, b)
                                    }
                                } else {
                                    // General indexed colorize
                                    let max = (1u16 << bitmap.original_bit_depth) - 1;
                                    let t = i as f32 / max as f32;

                                    if has_fore && has_back && use_back_color {
                                        // Interpolate between fg and bg based on palette index
                                        (
                                            ((1.0 - t) * fg_rgb.0 as f32 + t * bg_rgb.0 as f32) as u8,
                                            ((1.0 - t) * fg_rgb.1 as f32 + t * bg_rgb.1 as f32) as u8,
                                            ((1.0 - t) * fg_rgb.2 as f32 + t * bg_rgb.2 as f32) as u8,
                                        )
                                    } else if has_fore && i == 0 {
                                        // Replace palette index 0 with fg color
                                        fg_rgb
                                    } else {
                                        (r, g, b)
                                    }
                                }
                            } else {
                                (r, g, b)
                            }
                        }
                    }
                } else {
                    (r, g, b)
                };

                if a > 0 {
                    opaque_count += 1;
                } else {
                    transparent_count += 1;
                }

                rgba_data.push(final_r);
                rgba_data.push(final_g);
                rgba_data.push(final_b);
                rgba_data.push(a);
            }
        }

        // Unused variables to suppress warnings
        let _ = is_grayscale;
        let _ = opaque_count;
        let _ = transparent_count;

        rgba_data
    }

    /// Compute a matte mask using flood-fill from all edges for INDEXED bitmaps
    ///
    /// This compares PALETTE INDICES (not RGB values), matching how Canvas2D's
    /// create_matte works. Background is palette index 0.
    fn compute_edge_matte_mask_indexed(
        bitmap: &Bitmap,
        width: usize,
        height: usize,
    ) -> Vec<bool> {
        // Start with all pixels visible (true)
        let mut matte = vec![true; width * height];

        // Track which pixels we've visited during flood fill
        let mut visited = vec![false; width * height];

        // Stack for flood fill (use iterative approach to avoid stack overflow)
        let mut stack: Vec<(usize, usize)> = Vec::new();

        // Background color is palette index 0
        let bg_color_ref = ColorRef::PaletteIndex(0);

        // Helper to check if a pixel matches the background color (by palette index)
        let matches_bg = |x: usize, y: usize| -> bool {
            let pixel_ref = bitmap.get_pixel_color_ref(x as u16, y as u16);
            pixel_ref == bg_color_ref
        };

        // Seed the flood fill from all edge pixels that match bg color
        // Top and bottom edges
        for x in 0..width {
            if matches_bg(x, 0) {
                stack.push((x, 0));
            }
            if height > 1 && matches_bg(x, height - 1) {
                stack.push((x, height - 1));
            }
        }
        // Left and right edges (skip corners, already added)
        for y in 1..height.saturating_sub(1) {
            if matches_bg(0, y) {
                stack.push((0, y));
            }
            if width > 1 && matches_bg(width - 1, y) {
                stack.push((width - 1, y));
            }
        }

        // Flood fill - mark connected bg-color pixels as transparent
        while let Some((x, y)) = stack.pop() {
            let idx = y * width + x;

            // Skip if already visited
            if visited[idx] {
                continue;
            }
            visited[idx] = true;

            // Check if this pixel matches bg color (by palette index)
            if !matches_bg(x, y) {
                continue;
            }

            // Mark as transparent
            matte[idx] = false;

            // Add neighbors to stack (4-connected)
            if x > 0 {
                stack.push((x - 1, y));
            }
            if x + 1 < width {
                stack.push((x + 1, y));
            }
            if y > 0 {
                stack.push((x, y - 1));
            }
            if y + 1 < height {
                stack.push((x, y + 1));
            }
        }

        matte
    }

    /// Compute a matte mask using flood-fill from all edges for non-indexed bitmaps
    ///
    /// This compares RGB values, used for 16-bit bitmaps with ink 0 (Copy).
    fn compute_edge_matte_mask_rgb(
        bitmap: &Bitmap,
        palettes: &crate::player::bitmap::palette_map::PaletteMap,
        bg_color_rgb: (u8, u8, u8),
        width: usize,
        height: usize,
    ) -> Vec<bool> {
        // Start with all pixels visible (true)
        let mut matte = vec![true; width * height];

        // Track which pixels we've visited during flood fill
        let mut visited = vec![false; width * height];

        // Stack for flood fill (use iterative approach to avoid stack overflow)
        let mut stack: Vec<(usize, usize)> = Vec::new();

        // Helper to check if a pixel matches the background color (by RGB)
        let matches_bg = |x: usize, y: usize| -> bool {
            let (r, g, b) = bitmap.get_pixel_color(palettes, x as u16, y as u16);
            r == bg_color_rgb.0 && g == bg_color_rgb.1 && b == bg_color_rgb.2
        };

        // Seed the flood fill from all edge pixels that match bg color
        // Top and bottom edges
        for x in 0..width {
            if matches_bg(x, 0) {
                stack.push((x, 0));
            }
            if height > 1 && matches_bg(x, height - 1) {
                stack.push((x, height - 1));
            }
        }
        // Left and right edges (skip corners, already added)
        for y in 1..height.saturating_sub(1) {
            if matches_bg(0, y) {
                stack.push((0, y));
            }
            if width > 1 && matches_bg(width - 1, y) {
                stack.push((width - 1, y));
            }
        }

        // Flood fill - mark connected bg-color pixels as transparent
        while let Some((x, y)) = stack.pop() {
            let idx = y * width + x;

            // Skip if already visited
            if visited[idx] {
                continue;
            }
            visited[idx] = true;

            // Check if this pixel matches bg color (by RGB)
            if !matches_bg(x, y) {
                continue;
            }

            // Mark as transparent
            matte[idx] = false;

            // Add neighbors to stack (4-connected)
            if x > 0 {
                stack.push((x - 1, y));
            }
            if x + 1 < width {
                stack.push((x + 1, y));
            }
            if y > 0 {
                stack.push((x, y - 1));
            }
            if y + 1 < height {
                stack.push((x, y + 1));
            }
        }

        matte
    }

    /// Check if ink mode requires matte computation
    /// Matches Canvas2D's should_matte_sprite function
    fn should_matte_sprite(ink: i32) -> bool {
        ink == 36 || ink == 33 || ink == 41 || ink == 8 || ink == 7
    }

    /// Get or create a texture for a bitmap member
    ///
    /// The ink is included in the cache key because 32-bit bitmaps with ink 8 (Matte)
    /// need matte computation while other inks use the embedded alpha.
    ///
    /// Colorize parameters are also included in the cache key because Director's colorize
    /// feature remaps palette indices to interpolate between fore and back colors.
    fn get_or_create_texture(
        &mut self,
        player: &mut DirPlayer,
        member_ref: &CastMemberRef,
        image_ref: u32,
        ink: i32,
        colorize: Option<(bool, bool, u8, u8, u8, u8, u8, u8)>,
        sprite_bg_color: Option<(u8, u8, u8)>,
    ) -> Option<(web_sys::WebGlTexture, u32, u32)> {
        // For inks that need matte, ensure create_matte is called first
        // This matches Canvas2D behavior in rendering.rs
        // EXCEPTION: For 32-bit bitmaps with use_alpha=true, we use the embedded alpha channel
        // instead of computing a matte (matching drawing.rs lines 1268-1269)
        if Self::should_matte_sprite(ink) {
            let palettes = player.movie.cast_manager.palettes();
            if let Some(bitmap) = player.bitmap_manager.get_bitmap_mut(image_ref) {
                // Don't create matte for 32-bit bitmaps with embedded alpha
                // Use original_bit_depth since bit_depth can change during execution
                let use_embedded_alpha = bitmap.original_bit_depth == 32 && bitmap.use_alpha;
                if bitmap.matte.is_none() && !use_embedded_alpha {
                    bitmap.create_matte(&palettes);
                }
            }
        }

        // Get bitmap data to check version
        let bitmap = player.bitmap_manager.get_bitmap(image_ref)?;
        if bitmap.data.is_empty() {
            return None;
        }

        let bitmap_version = bitmap.version;
        let width = bitmap.width as u32;
        let height = bitmap.height as u32;

        // Create cache key including ink, colorize, and sprite_bg_color for inks that use bgColor matte
        // These inks use bgColor for matte/transparency computation:
        // - Ink 7: indexed bitmaps (not ghost - skips bgColor pixels via flood-fill matte)
        // - Ink 8: indexed bitmaps and 32-bit bitmaps without use_alpha (flood-fill matte)
        // - Ink 9: 32-bit bitmaps without use_alpha (mask with bgColor-based matte)
        // - Ink 40: indexed bitmaps (lighten - skips bgColor pixels via RGB comparison)
        // - Ink 41: 32-bit bitmaps without use_alpha (darken with bgColor-based matte)
        // Note: Ink 33 uses shader color-key, not texture matte, so no bgColor in cache key
        // Note: Ink 41 for indexed bitmaps uses palette index 0, not bgColor
        let is_ink_with_bgcolor_matte =
            ((ink == 7 || ink == 8 || ink == 40) && bitmap.original_bit_depth >= 2 && bitmap.original_bit_depth <= 8)
            || (ink == 8 && bitmap.original_bit_depth == 32 && !bitmap.use_alpha)
            || ((ink == 9 || ink == 41) && bitmap.original_bit_depth == 32 && !bitmap.use_alpha);
        let cache_key_bg_color = if is_ink_with_bgcolor_matte {
            sprite_bg_color
        } else {
            None
        };
        let cache_key = TextureCacheKey {
            member_ref: member_ref.clone(),
            ink,
            colorize,
            sprite_bg_color: cache_key_bg_color,
        };

        // Check cache - return cached texture if version matches
        if let Some(cached) = self.texture_cache.get(&cache_key) {
            if cached.version == bitmap_version {
                return Some((cached.texture.clone(), cached.width, cached.height));
            }
            // Version changed - texture needs to be re-uploaded (don't log to avoid spam)
        }

        // Convert bitmap to RGBA format with ink for matte computation
        let palettes = player.movie.cast_manager.palettes();

        // Only log on the very first frame for any new texture
        let _is_first_creation = self.frame_count == 1 && !self.texture_cache.has(&cache_key);

        let rgba_data = Self::bitmap_to_rgba(bitmap, &palettes, ink, colorize, sprite_bg_color);

        // Validate data size
        let expected_size = (width * height * 4) as usize;
        if rgba_data.len() != expected_size {
            web_sys::console::warn_1(
                &format!(
                    "WebGL2: RGBA data size mismatch for member {:?}: expected {}, got {}",
                    member_ref, expected_size, rgba_data.len()
                ).into()
            );
            return None;
        }

        // Create texture
        let texture = self.context.create_texture().ok()?;

        // Upload RGBA data to texture
        self.context
            .upload_texture_rgba(
                &texture,
                width,
                height,
                &rgba_data,
            )
            .ok()?;

        // Cache the texture with current bitmap version
        self.texture_cache.insert(
            cache_key,
            texture.clone(),
            width,
            height,
            bitmap_version,
        );

        Some((texture, width, height))
    }

    /// Get or create a 1x1 solid color texture for shape rendering
    fn get_or_create_solid_color_texture(&mut self, r: u8, g: u8, b: u8) -> web_sys::WebGlTexture {
        let key = (r, g, b);

        // Check if we already have this color cached
        if let Some(texture) = self.solid_color_textures.get(&key) {
            return texture.clone();
        }

        // Create a new 1x1 RGBA texture with the solid color
        let rgba_data: [u8; 4] = [r, g, b, 255];

        let texture = self.context.create_texture().expect("Failed to create solid color texture");

        self.context
            .upload_texture_rgba(&texture, 1, 1, &rgba_data)
            .expect("Failed to upload solid color texture");

        // Cache the texture
        self.solid_color_textures.insert(key, texture.clone());

        texture
    }

    /// Render text to a CPU bitmap, then upload as a WebGL texture
    ///
    /// This allows us to reuse the existing text rendering code from Canvas2D
    /// while still benefiting from GPU compositing for the final render.
    #[allow(clippy::too_many_arguments)]
    fn render_text_to_texture(
        &mut self,
        player: &mut DirPlayer,
        cache_key: &RenderedTextCacheKey,
        text: &str,
        font_name: &str,
        font_size: u16,
        font_style: Option<u8>,
        line_spacing: u16,
        top_spacing: i16,
        width: u32,
        height: u32,
        ink: i32,
        blend: i32,
        fg_color: &ColorRef,
        bg_color: &ColorRef,
        styled_spans: Option<&Vec<StyledSpan>>,
        alignment: &str,
        word_wrap: bool,
    ) -> Option<web_sys::WebGlTexture> {
        // Get or load the font
        let font = {
            let font_opt = player.font_manager.get_font_with_cast(
                font_name,
                Some(&player.movie.cast_manager),
                Some(font_size),
                font_style,
            );

            font_opt.or_else(|| player.font_manager.get_system_font())
        };

        let font = match font {
            Some(f) => f,
            None => {
                // No font available - log warning and return None
                web_sys::console::warn_1(
                    &format!("WebGL2 render_text_to_texture: No font found for '{}' size {}", font_name, font_size).into()
                );
                return None;
            }
        };

        // Get the font bitmap
        let font_bitmap = match player.bitmap_manager.get_bitmap(font.bitmap_ref) {
            Some(b) => b,
            None => {
                // Font bitmap not found - log warning and return None
                web_sys::console::warn_1(
                    &format!("WebGL2 render_text_to_texture: Font bitmap {} not found", font.bitmap_ref).into()
                );
                return None;
            }
        };

        // Create a 32-bit RGBA bitmap for rendering text
        let mut text_bitmap = Bitmap::new(
            width as u16,
            height as u16,
            32,
            32,
            0,
            PaletteRef::BuiltIn(get_system_default_palette()),
        );

        // Fill with white background (will be made transparent via matte/color-key)
        // Bitmap::new initializes 32-bit data to 255, so it's already white/opaque
        // No need to modify the initial data

        let palettes = player.movie.cast_manager.palettes();

        // Set up copy parameters for text rendering
        // Use ink 36 (background transparent) so white pixels become transparent
        let params = CopyPixelsParams {
            blend,
            ink: 36, // Background transparent - white background becomes transparent
            color: fg_color.clone(),
            bg_color: ColorRef::Rgb(255, 255, 255), // White background for transparency
            mask_image: None,
            is_text_rendering: true,
            rotation: 0.0,
            sprite: None,
            original_dst_rect: None,
        };

        // Render text to the bitmap - use styled spans if available
        if let Some(spans) = styled_spans {
            // Parse alignment string to TextAlignment enum
            let text_alignment = match alignment.to_lowercase().as_str() {
                "center" | "#center" => TextAlignment::Center,
                "right" | "#right" => TextAlignment::Right,
                "justify" | "#justify" => TextAlignment::Justify,
                _ => TextAlignment::Left,
            };

            // Use native browser text rendering for smooth, anti-aliased text
            // Don't pass fg_color since colors are now in the styled spans
            if let Err(e) = FontMemberHandlers::render_native_text_to_bitmap(
                &mut text_bitmap,
                spans,
                0,  // loc_h - render at origin
                top_spacing as i32,  // loc_v
                width as i32,
                height as i32,
                text_alignment,
                width as i32,
                word_wrap,
                None, // Color is in the spans
                line_spacing,
            ) {
                web_sys::console::warn_1(
                    &format!("WebGL2 render_text_to_texture: Native text render error: {:?}", e).into()
                );
            }
        } else {
            text_bitmap.draw_text(
                text,
                &font,
                font_bitmap,
                0,  // loc_h - render at origin
                0,  // loc_v - render at origin
                params,
                &palettes,
                line_spacing,
                top_spacing,
            );
        }

        // After drawing text, convert white pixels to transparent
        // This simulates Director's background transparent ink behavior
        for i in 0..text_bitmap.data.len() / 4 {
            let r = text_bitmap.data[i * 4];
            let g = text_bitmap.data[i * 4 + 1];
            let b = text_bitmap.data[i * 4 + 2];
            // If pixel is white (or near-white), make it transparent
            if r >= 250 && g >= 250 && b >= 250 {
                text_bitmap.data[i * 4 + 3] = 0; // Set alpha to 0
            }
        }

        // Render cursor/caret if the field has focus
        if cache_key.has_focus {
            // Measure text to find cursor position (at end of text)
            let (text_width, _) = measure_text(
                text,
                &font,
                None,
                line_spacing,
                top_spacing,
            );

            let cursor_x = text_width as i32;
            let cursor_y = top_spacing as i32;
            let cursor_width = 1;
            let cursor_height = font.char_height as i32;

            // Draw black cursor line
            text_bitmap.fill_rect(
                cursor_x,
                cursor_y,
                cursor_x + cursor_width,
                cursor_y + cursor_height,
                (0, 0, 0),
                &palettes,
                1.0,
            );
        }

        // Upload the bitmap as a texture
        let texture = self.context.create_texture().ok()?;
        self.context
            .upload_texture_rgba(&texture, width, height, &text_bitmap.data)
            .ok()?;

        // Cache the texture
        self.rendered_text_cache.insert(
            cache_key.clone(),
            texture.clone(),
            width,
            height,
        );

        Some(texture)
    }

    /// Set preview size
    pub fn set_preview_size(&mut self, width: u32, height: u32) {
        self.preview_size = (width, height);
        self.preview_canvas.set_width(width);
        self.preview_canvas.set_height(height);
    }

    /// Set preview container element
    pub fn set_preview_container_element(
        &mut self,
        container_element: Option<web_sys::HtmlElement>,
    ) {
        if self.preview_canvas.parent_node().is_some() {
            self.preview_canvas.remove();
        }
        if let Some(container_element) = container_element {
            container_element
                .append_child(&self.preview_canvas)
                .unwrap();
            self.preview_container_element = Some(container_element);
        } else {
            self.preview_container_element = None;
        }
    }

    /// Set preview member reference
    pub fn set_preview_member_ref(&mut self, member_ref: Option<CastMemberRef>) {
        self.preview_member_ref = member_ref;
    }

    /// Draw the preview frame using Canvas2D
    pub fn draw_preview_frame(&mut self, player: &mut DirPlayer) {
        use wasm_bindgen::Clamped;

        if self.preview_member_ref.is_none()
            || self.preview_container_element.is_none()
        {
            return;
        }

        let member_ref = self.preview_member_ref.as_ref().unwrap();
        let member = player.movie.cast_manager.find_member_by_ref(member_ref);
        if member.is_none() {
            return;
        }
        let member = member.unwrap();

        match &member.member_type {
            CastMemberType::Bitmap(sprite_member) => {
                let sprite_bitmap = player.bitmap_manager.get_bitmap(sprite_member.image_ref);
                if sprite_bitmap.is_none() {
                    return;
                }
                let sprite_bitmap = sprite_bitmap.unwrap();
                let width = sprite_bitmap.width as u32;
                let height = sprite_bitmap.height as u32;

                // Create a 32-bit bitmap for display
                let mut bitmap = Bitmap::new(
                    width as u16,
                    height as u16,
                    32,
                    32,
                    0,
                    PaletteRef::BuiltIn(get_system_default_palette()),
                );

                let palettes = &player.movie.cast_manager.palettes();

                // Fill with background color
                bitmap.fill_relative_rect(
                    0,
                    0,
                    0,
                    0,
                    resolve_color_ref(
                        &palettes,
                        &player.bg_color,
                        &PaletteRef::BuiltIn(get_system_default_palette()),
                        sprite_bitmap.original_bit_depth,
                    ),
                    palettes,
                    1.0,
                );

                // Copy the sprite bitmap
                bitmap.copy_pixels(
                    &palettes,
                    sprite_bitmap,
                    crate::player::geometry::IntRect::from(
                        0,
                        0,
                        sprite_bitmap.width as i32,
                        sprite_bitmap.height as i32,
                    ),
                    crate::player::geometry::IntRect::from(
                        0,
                        0,
                        sprite_bitmap.width as i32,
                        sprite_bitmap.height as i32,
                    ),
                    &HashMap::new(),
                    None,
                );

                // Mark registration point with magenta
                bitmap.set_pixel(
                    sprite_member.reg_point.0 as i32,
                    sprite_member.reg_point.1 as i32,
                    (255, 0, 255),
                    palettes,
                );

                // Update preview size if needed
                if self.preview_size.0 != width || self.preview_size.1 != height {
                    self.set_preview_size(width, height);
                }

                // Render to canvas using ImageData
                let slice_data = Clamped(bitmap.data.as_slice());
                let image_data = web_sys::ImageData::new_with_u8_clamped_array_and_sh(
                    slice_data,
                    width,
                    height,
                );

                if let Ok(image_data) = image_data {
                    let _ = self.preview_ctx2d.put_image_data(&image_data, 0.0, 0.0);
                }
            }
            CastMemberType::FilmLoop(loop_member) => {
                let width = loop_member.info.width as u32;
                let height = loop_member.info.height as u32;

                // Create a bitmap for the film loop
                let mut bitmap = Bitmap::new(
                    width as u16,
                    height as u16,
                    32,
                    32,
                    0,
                    PaletteRef::BuiltIn(get_system_default_palette()),
                );

                // Render the film loop score to bitmap
                crate::rendering::render_score_to_bitmap(
                    player,
                    &ScoreRef::FilmLoop(member_ref.clone()),
                    &mut bitmap,
                    None,
                    crate::player::geometry::IntRect::from_size(0, 0, width as i32, height as i32),
                );

                // Update preview size if needed
                if self.preview_size.0 != width || self.preview_size.1 != height {
                    self.set_preview_size(width, height);
                }

                // Render to canvas using ImageData
                let slice_data = Clamped(bitmap.data.as_slice());
                let image_data = web_sys::ImageData::new_with_u8_clamped_array_and_sh(
                    slice_data,
                    width,
                    height,
                );

                if let Ok(image_data) = image_data {
                    let _ = self.preview_ctx2d.put_image_data(&image_data, 0.0, 0.0);
                }
            }
            _ => {}
        }
    }

    /// Set the canvas size
    pub fn set_size(&mut self, width: u32, height: u32) {
        self.size = (width, height);
        self.canvas.set_width(width);
        self.canvas.set_height(height);
        self.context.gl().viewport(0, 0, width as i32, height as i32);
        // Update projection matrix for new size
        self.projection_matrix = Self::create_ortho_matrix(width as f32, height as f32);
    }

    /// Get the canvas
    pub fn canvas(&self) -> &HtmlCanvasElement {
        &self.canvas
    }

    /// Get the size
    pub fn size(&self) -> (u32, u32) {
        self.size
    }

    /// Get the backend name
    pub fn backend_name(&self) -> &'static str {
        "WebGL2"
    }
}

impl super::Renderer for WebGL2Renderer {
    fn draw_frame(&mut self, player: &mut DirPlayer) {
        WebGL2Renderer::draw_frame(self, player)
    }

    fn draw_preview_frame(&mut self, player: &mut DirPlayer) {
        WebGL2Renderer::draw_preview_frame(self, player)
    }

    fn set_size(&mut self, width: u32, height: u32) {
        WebGL2Renderer::set_size(self, width, height)
    }

    fn size(&self) -> (u32, u32) {
        WebGL2Renderer::size(self)
    }

    fn backend_name(&self) -> &'static str {
        WebGL2Renderer::backend_name(self)
    }

    fn canvas(&self) -> &HtmlCanvasElement {
        WebGL2Renderer::canvas(self)
    }

    fn set_preview_member_ref(&mut self, member_ref: Option<CastMemberRef>) {
        WebGL2Renderer::set_preview_member_ref(self, member_ref)
    }

    fn set_preview_container_element(&mut self, container_element: Option<web_sys::HtmlElement>) {
        WebGL2Renderer::set_preview_container_element(self, container_element)
    }
}
